CREATE OR REPLACE VIEW V_MOVIES_QUICK AS
SELECT
	MOVIE_NAME,
	MOVIE_LENGTH,
	RELEASE_DATE
FROM
	MOVIES MV;

-- BELOW CODE WILL GIVE AN ERROR SAYING, THAT DIRECTOR_ID SPECIFIED MORE THAN ONCE
-- SO THIS MEANS IT IS NOT POSSIBLE TO DISPLAT THE SAME COLUMN AGAIN AND AGAIN
CREATE OR REPLACE VIEW MOVIES_DIRECTORS_ALL AS
SELECT
	*
FROM
	MOVIES MV
	INNER JOIN DIRECTORS DR ON DR.DIRECTOR_ID = MV.DIRECTOR_ID;

CREATE OR REPLACE VIEW V_MOVIES_DIRECTORS_ALL AS
SELECT
	MV.MOVIE_ID,
	MV.MOVIE_NAME,
	MV.MOVIE_LENGTH,
	MV.MOVIE_LANGUAGE,
	MV.AGE_CERTIFICATE,
	MV.RELEASE_DATE,
	DR.DIRECTOR_ID,
	CONCAT(DR.FIRST_NAME, ' ', DR.LAST_NAME),
	DR.DATE_OF_BIRTH,
	DR.NATIONALITY
FROM
	MOVIES MV
	INNER JOIN DIRECTORS DR ON DR.DIRECTOR_ID = MV.DIRECTOR_ID;

SELECT
	*
FROM
	V_MOVIE_QUICK;

SELECT
	*
FROM
	V_MOVIES_DIRECTORS_ALL;

----------------------------------------------------------------------------------------------------
-- Rename a view
ALTER VIEW V_MOVIE_QUICK
RENAME TO V_MOVIES_QUICK;

----------------------------------------------------------------------------------------------------
-- Delete a view
-- FOR OPERATION REGARDING TO DELETING SOMETHING ALWAYS USE PGADMIN UI AS IT ASKS FOR SURITY, DO NOT RUN COMMANDS
DROP VIEW V_MOVIES_QUICK;

----------------------------------------------------------------------------------------------------
-- Using filters with views
CREATE OR REPLACE VIEW V_MOVIES_AFTER_1997 AS
SELECT
	MOVIE_NAME,
	RELEASE_DATE,
	MOVIE_LANGUAGE,
	AGE_CERTIFICATE
FROM
	MOVIES
WHERE
	RELEASE_DATE > '1997-12-31'
ORDER BY
	RELEASE_DATE;

SELECT
	*
FROM
	V_MOVIES_AFTER_1997;

SELECT
	*
FROM
	V_MOVIES_AFTER_1997
WHERE
	MOVIE_LANGUAGE = 'English'
	AND AGE_CERTIFICATE = '12';

-- THIS IS USING THE QUERY, WHERE IT NEEDS TO MENTION AL THOSE CONSTRAINTS AGAIN
SELECT
	MV.MOVIE_ID,
	MV.MOVIE_NAME,
	MV.MOVIE_LENGTH,
	MV.MOVIE_LANGUAGE,
	MV.AGE_CERTIFICATE,
	MV.RELEASE_DATE,
	DR.DIRECTOR_ID,
	CONCAT(DR.FIRST_NAME, ' ', DR.LAST_NAME),
	DR.DATE_OF_BIRTH,
	DR.NATIONALITY
FROM
	MOVIES MV
	INNER JOIN DIRECTORS DR ON DR.DIRECTOR_ID = MV.DIRECTOR_ID
WHERE
	DR.NATIONALITY IN ('American', 'Japanese');

-- INSTEAD TO AVOID REDUNDANT QUERIES, USE PRE DEFINED VIEWS
-- THIS IS MORE CONCISE
-- WE DO NOT NEED TO USE ALIASES AT ALL, EVERYTHING IS TAKEN CARE BY VIEWS
SELECT
	*
FROM
	V_MOVIES_DIRECTORS_ALL;

WHERE
	NATIONALITY IN ('American', 'Japanese');

----------------------------------------------------------------------------------------------------
-- A view with UNION of multiple tables
CREATE VIEW V_ALL_ACTORS_DIRECTORS AS
SELECT
	FIRST_NAME,
	LAST_NAME,
	'ACTOR' AS PEOPLE_TYPE
FROM
	ACTORS
UNION ALL
SELECT
	FIRST_NAME,
	LAST_NAME,
	'DIRECTOR' AS PEOPLE_TYPE
FROM
	DIRECTORS;

SELECT
	*
FROM
	V_ALL_ACTORS_DIRECTORS
WHERE
	FIRST_NAME LIKE 'J%'
ORDER BY
	PEOPLE_TYPE,
	FIRST_NAME;

----------------------------------------------------------------------------------------------------
-- Connecting multiple tables with a single view
-- CONNECTING MOVIES, DIRECTORS AND REVENUE TABLE WITH THE SINGLE VIEW
CREATE VIEW V_MOVIES_DIRECTORS_REVENUES AS
SELECT
	MV.MOVIE_ID,
	MV.MOVIE_NAME,
	MV.MOVIE_LENGTH,
	MV.MOVIE_LANGUAGE,
	MV.AGE_CERTIFICATE,
	MV.RELEASE_DATE,
	DR.DIRECTOR_ID,
	CONCAT(DR.FIRST_NAME, ' ', DR.LAST_NAME),
	DR.DATE_OF_BIRTH,
	DR.NATIONALITY,
	R.REVENUE_ID,
	COALESCE(R.REVENUES_DOMESTIC, 0) DOMESTIC_REVENUE,
	COALESCE(R.REVENUES_INTERNATIONAL, 0) INTERNATIONAL_REVENUE,
	-- SO A VERY GOOD POINT, THERE IS NOTHING WRONG WITH USING SUM FUNCTION HERE
	-- AND IT WILL IT SELF HANDLE ALL THOSE NULL VALUES AS 0
	-- SO NO NEED TO USE COALESCE,
	-- BUT THE THING IS THAT ON USING AGGREGATE FUNCTION ON THE REVENUES, 
	-- IT WILL REQUIRE THE REST OF THE ATTRIBUTES TO BE INSIDE THE GROUP BY CLAUSE
	-- AND IT WILL BE VERY REDUNDANT BLOCKS OF CODE, SO COALESCE IS BETTER OPTION IN SUCH CASES
	-- SUM(R.REVENUES_DOMESTIC + R.REVENUES_INTERNATIONAL) NET_REVENUE
	COALESCE(R.REVENUES_DOMESTIC, 0) + COALESCE(R.REVENUES_INTERNATIONAL, 0) NET_REVENUE
FROM
	MOVIES MV
	INNER JOIN DIRECTORS DR ON DR.DIRECTOR_ID = MV.DIRECTOR_ID
	INNER JOIN MOVIES_REVENUES R ON R.MOVIE_ID = MV.MOVIE_ID
ORDER BY
	MOVIE_NAME,
	NET_REVENUE;

SELECT
	*
FROM
	V_MOVIES_DIRECTORS_REVENUES
WHERE
	AGE_CERTIFICATE = '12';

----------------------------------------------------------------------------------------------------
-- Re-arrange columns in a view
-- SUCH THING CAN BE DONE BY USING UI OF PG-ADMIN BY ALTERING THE CURRENT VIEW NAME AND RUNNING THE MODIFIED VIEW QUERY
-- THEN DELETE THE OLDER ONE
CREATE OR REPLACE VIEW V_DIRECTORS AS
SELECT
	FIRST_NAME,
	LAST_NAME
FROM
	DIRECTORS;

SELECT
	*
FROM
	V_DIRECTORS;

----------------------------------------------------------------------------------------------------
-- Delete a column in a view
----------------------------------------------------------------------------------------------------
-- Add a column in a view
CREATE OR REPLACE VIEW V_DIRECTORS AS
SELECT
	FIRST_NAME,
	LAST_NAME,
	NATIONALITY
FROM
	DIRECTORS;

UPDATE DIRECTORS
SET
	NATIONALITY = 'Indian'
WHERE
	DIRECTOR_ID = 38;

----------------------------------------------------------------------------------------------------
-- Regular views are dynamic
INSERT INTO
	DIRECTORS (FIRST_NAME, LAST_NAME, NATIONALITY)
VALUES
	('E', 'F', 'Indian');

-- ON ADDING THE DATA INSIDE OF THE BASE TABLE IT GETS REFLECTED INTO THE CORESPONDING VIEW, EVEN AFTER NOT CREATING THE SAME VIEW AGAIN
-- SO THAT MEANS THAT THE REGULAR TABLE DOES NOT SORE THE DATA PHYSICALLY, IT YIELDS UPDATED DATA AS ALWAYS
SELECT
	*
FROM
	V_DIRECTORS;

----------------------------------------------------------------------------------------------------
-- An updatable view with CRUD operations
CREATE OR REPLACE VIEW VU_DIRECTORS AS
SELECT
	FIRST_NAME,
	LAST_NAME
FROM
	DIRECTORS;

INSERT INTO
	VU_DIRECTORS (FIRST_NAME)
VALUES
	('DIR1'),
	('DIR2');

SELECT
	*
FROM
	VU_DIRECTORS;

SELECT
	*
FROM
	DIRECTORS;

DELETE FROM VU_DIRECTORS
WHERE
	FIRST_NAME = 'DIR1';

----------------------------------------------------------------------------------------------------
-- Updatable views using WITH CHECK OPTION
CREATE TABLE COUNTRIES (
	COUNTRY_ID SERIAL PRIMARY KEY,
	COUNTRY_CODE VARCHAR(4),
	CITY_NAME VARCHAR(100)
);

INSERT INTO
	V_CITITES_US (COUNTRY_CODE, CITY_NAME)
VALUES
	('UK', 'LEEDS');

SELECT
	*
FROM
	COUNTRIES;

CREATE OR REPLACE VIEW V_CITITES_US AS
SELECT
	COUNTRY_ID,
	COUNTRY_CODE,
	CITY_NAME
FROM
	COUNTRIES
WHERE
	COUNTRY_CODE = 'US'
WITH
	CHECK OPTION;

SELECT
	*
FROM
	V_CITITES_US;

-- WITH CHECK OPTION, PREVENTS FOLLOWING OPERATION
UPDATE V_CITITES_US
SET
	COUNTRY_CODE = 'UK'
WHERE
	CITY_NAME = 'NYC';

INSERT INTO
	V_CITITES_US (COUNTRY_CODE, CITY_NAME)
VALUES
	('US', 'LOS ANGELES');

-- Updatable views using WITH LOCAL and CASCADED CHECK OPTION
CREATE OR REPLACE VIEW V_CITIES_C AS
SELECT
	COUNTRY_ID,
	COUNTRY_CODE,
	CITY_NAME
FROM
	COUNTRIES
WHERE
	CITY_NAME LIKE 'C%';

SELECT
	*
FROM
	V_CITIES_C;

CREATE OR REPLACE VIEW C_CITIES_C_US AS
SELECT
	*
FROM
	V_CITIES_C
WHERE
	COUNTRY_CODE = 'US'
WITH
	LOCAL CHECK OPTION
SELECT
	*
FROM
	C_CITIES_C_US;

----------------------------------------------------------------------------------------------------
-- WITH LOCAL AND CASCADED CHECK OPTION
-- WITH LOCAL CHECK OPTION
CREATE OR REPLACE VIEW VIEW_CITIES_C AS
SELECT
	COUNTRY_ID,
	COUNTRY_CODE,
	CITY_NAME
FROM
	COUNTRIES
WHERE
	CITY_NAME LIKE 'C%';

SELECT
	*
FROM
	VIEW_CITIES_C;

CREATE OR REPLACE VIEW VIEW_CITIES_US_C AS
SELECT
	COUNTRY_ID,
	COUNTRY_CODE,
	CITY_NAME
FROM
	VIEW_CITIES_C
WHERE
	COUNTRY_CODE = 'US'
WITH
	LOCAL CHECK OPTION;

INSERT INTO
	VIEW_CITIES_US_C (COUNTRY_CODE, CITY_NAME)
VALUES
	('US', 'Connecticut');

SELECT
	*
FROM
	VIEW_CITIES_US_C;

INSERT INTO
	VIEW_CITIES_US_C (COUNTRY_CODE, CITY_NAME)
VALUES
	('US', 'Los Angeles');

SELECT
	*
FROM
	VIEW_CITIES_US_C;

SELECT
	*
FROM
	COUNTRIES;

----------------------------------------------------------------------------------------------------
-- WITH CASCADED CHECK OPTION
-- CASCADED CHEK OPTION CHECKS FOR ALL THE UNDERLYING CHECKS, NOT ONLY THE LOCAL CHECKS
CREATE OR REPLACE VIEW VIEW_CITIES_US_C AS
SELECT
	COUNTRY_ID,
	COUNTRY_CODE,
	CITY_NAME
FROM
	VIEW_CITIES_C
WHERE
	COUNTRY_CODE = 'US'
WITH
	-- CHECK OPTION; THIS QUIVALENT TO BELOW CODE
	CASCADED CHECK OPTION;

INSERT INTO
	VIEW_CITIES_US_C (COUNTRY_CODE, CITY_NAME)
VALUES
	('US', 'Boston');

INSERT INTO
	VIEW_CITIES_US_C (COUNTRY_CODE, CITY_NAME)
VALUES
	('US', 'Clear Water');

SELECT
	*
FROM
	VIEW_CITIES_US_C;

----------------------------------------------------------------------------------------------------
-- What is a Materialized View
SELECT
	FIRST_NAME,
	LAST_NAME
FROM
	DIRECTORS;

CREATE MATERIALIZED VIEW IF NOT EXISTS MV_DIRECTORS AS
SELECT
	FIRST_NAME,
	LAST_NAME
FROM
	DIRECTORS
WITH
	DATA;

SELECT
	*
FROM
	MV_DIRECTORS;

CREATE MATERIALIZED VIEW IF NOT EXISTS MV_DIRECTORS_NODATA AS
SELECT
	FIRST_NAME,
	LAST_NAME
FROM
	DIRECTORS
WITH
	NO DATA;

SELECT
	*
FROM
	MV_DIRECTORS_NODATA;

----------------------------------------------------------------------------------------------------
-- Drop a materialized view
DROP MATERIALIZED VIEW MV_DIRECTORS_NODATA;

----------------------------------------------------------------------------------------------------
-- CHANGE MATERIALIZED VIEW DATA
SELECT
	*
FROM
	MV_DIRECTORS;

INSERT INTO
	MV_DIRECTORS (FIRST_NAME, LAST_NAME)
VALUES
	('Christopher', 'Nolan');

INSERT INTO
	DIRECTORS (FIRST_NAME, LAST_NAME)
VALUES
	('Christopher', 'Nolan');

SELECT
	*
FROM
	MV_DIRECTORS;

REFRESH MATERIALIZED VIEW MV_DIRECTORS;

SELECT
	*
FROM
	MV_DIRECTORS;

DELETE FROM MV_DIRECTORS
WHERE
	FIRST_NAME = 'Christopher';

UPDATE MV_DIRECTORS
SET
	FIRST_NAME = 'Chris'
WHERE
	FIRST_NAME = 'Christopher';

----------------------------------------------------------------------------------------------------
-- MATERIALIZED VIEW IS POPULATED OR NOT
CREATE MATERIALIZED VIEW MV_DIRECTORS_NODATA AS
SELECT
	FIRST_NAME,
	LAST_NAME
FROM
	DIRECTORS
WITH
	NO DATA;

SELECT
	*
FROM
	MV_DIRECTORS_NODATA;

SELECT
	RELISPOPULATED
FROM
	PG_CLASS
WHERE
	RELNAME = 'mv_directors_nodata';

-- REFRESH DATA
CREATE MATERIALIZED VIEW MV_DIRECTORS_US AS
SELECT
	DIRECTOR_ID,
	FIRST_NAME,
	LAST_NAME,
	DATE_OF_BIRTH,
	NATIONALITY
FROM
	DIRECTORS
WHERE
	NATIONALITY = 'American'
WITH
	NO DATA;

SELECT
	*
FROM
	MV_DIRECTORS_US;

REFRESH MATERIALIZED VIEW MV_DIRECTORS_US;

SELECT
	*
FROM
	MV_DIRECTORS_US;

CREATE UNIQUE INDEX IDX_U_MV_DIRECTORS_US_DIRECTOR_ID ON MV_DIRECTORS_US (DIRECTOR_ID);

REFRESH MATERIALIZED VIEW CONCURRENTLY MV_DIRECTORS_US;

SELECT
	*
FROM
	MV_DIRECTORS_US;

----------------------------------------------------------------------------------------------------
-- MATERIALIZED VIEW FOR WEBSITE PAGE ANALYSIS
CREATE TABLE PAGE_CLICKS (
	REC_ID SERIAL PRIMARY KEY,
	PAGE VARCHAR(200),
	CLICK_TIME TIMESTAMP,
	USER_ID BIGINT
);

INSERT INTO
	PAGE_CLICKS (PAGE, CLICK_TIME, USER_ID)
SELECT
	(
		CASE (RANDOM() * 2)::INT
			WHEN 0 THEN 'klickanalytics.com'
			WHEN 1 THEN 'clickapis.com'
			WHEN 2 THEN 'google.com'
		END
	) AS PAGE,
	NOW() AS CLICK_TIME,
	(
		FLOOR(RANDOM() * (111111111 - 1000000 - 1) + 1000000)
	)::INT AS USER_ID
FROM
	GENERATE_SERIES(1, 10000) AS "Sequence";

SELECT
	*
FROM
	PAGE_CLICKS;

CREATE MATERIALIZED VIEW MV_PAGE_CLICKS AS
SELECT
	DATE_TRUNC('DAY', CLICK_TIME) AS "Day",
	PAGE,
	COUNT(*) AS TOTAL_CLICKS
FROM
	PAGE_CLICKS
GROUP BY
	"Day",
	PAGE;

REFRESH MATERIALIZED VIEW MV_PAGE_CLICKS;

SELECT
	*
FROM
	MV_PAGE_CLICKS;

CREATE MATERIALIZED VIEW MV_PAGE_CLICKS_DAILY AS
SELECT
	CLICK_TIME AS "Day",
	PAGE,
	COUNT(*) AS "Count"
FROM
	PAGE_CLICKS
WHERE
	CLICK_TIME >= DATE_TRUNC('DAY', NOW())
	AND CLICK_TIME < TIMESTAMP 'TOMORROW'
GROUP BY
	"Day",
	PAGE;

CREATE UNIQUE INDEX IDX_U_MV_PAGE_CLICKS_DAILY_DAY_PAGE ON MV_PAGE_CLICKS_DAILY ("Day", PAGE);

REFRESH MATERIALIZED VIEW CONCURRENTLY MV_PAGE_CLICKS_DAILY;

SELECT
	*
FROM
	MV_PAGE_CLICKS_DAILY;

----------------------------------------------------------------------------------------------------
-- LIST MATERIALIZED VIEWS
SELECT
	OID::REGCLASS::TEXT
FROM
	PG_CLASS
WHERE
	RELKIND = 'm';

----------------------------------------------------------------------------------------------------
-- LIST MATERIALIZED VIEWS WITH NO UNIQUE INDEX
WITH
	MATVIEWS_WITH_NO_UNIQUE_KEYS AS (
		SELECT
			C.OID,
			C.RELNAME,
			C2.RELNAME AS IDX_NAME
		FROM
			PG_CATALOG.PG_CLASS AS C,
			PG_CATALOG.PG_CLASS AS C2,
			PG_CATALOG.PG_INDEX AS I
			LEFT JOIN PG_CATALOG.PG_CONSTRAINT AS CON ON (
				CONRELID = I.INDRELID
				AND CONRELID = I.INDEXRELID
				AND CONTYPE IN ('p', 'u')
			)
		WHERE
			C.RELKIND = 'm'
			AND C.OID = I.INDRELID
			AND I.INDEXRELID = C2.OID
			AND INDISUNIQUE
	)
SELECT
	C.RELNAME AS MATERILIAZED_VIEW_NAME
FROM
	PG_CLASS AS C
WHERE
	C.RELKIND = 'm'
EXCEPT
SELECT
	MWK.RELNAME
FROM
	MATVIEWS_WITH_NO_UNIQUE_KEYS AS MWK;

----------------------------------------------------------------------------------------------------
-- QUICK QUERIES FOR MATERIALIZED VIEWS
-- WHETHER MATERIALIZED VIEW EXISTS
SELECT
	COUNT(*) > 0
FROM
	PG_CATALOG.PG_CLASS AS C
	JOIN PG_NAMESPACE AS N ON N.OID = C.RELNAMESPACE
WHERE
	C.RELKIND = 'm'
	AND N.NSPNAME = 'some_schema'
	AND C.RELNAME = 'some_mat_view';

SELECT
	VIEW_DEFINITION
FROM
	INFORMATION_SCHEMA.VIEWS
WHERE
	TABLE_SCHEMA = 'information_schema'
	AND TABLE_NAME = 'views';

----------------------------------------------------------------------------------------------------
-- 	LIST MATERIALIZED VIEWS
SELECT
	*
FROM
	PG_MATVIEWS;

SELECT
	*
FROM
	PG_MATVIEWS
WHERE
	MATVIEWNAME = 'view_name';